<?php
/**
* Wordpress Command Line Interface
*
* This CLI is designed to help with development of advanced Wordpress Themes.
* Users can use compile:dev to automatically recompile live changes and
* compile:release to automatically compile a Word Press approved theme package
* for example.
*
* This CLI expects a certian layout of files and directories to work correctly,
* do not remove the original structure (boilerplate) of this theme. Directories
* can be added and ignored with the release file in this same directory.
*
* @author Christopher Keers <source@caboodle.tech>
*/

/**
* Only run commands if the user is using the command line or
* an equivalent shell or terminal.
*/
if( is_cli()===true && http_response_code()===false ){

    /** Change the working directory outside of bin. */
    chdir ( '../' );

    /** Attempt to record the command the user ran. */
    $cmd = '';
    if( $argc > 1 ){
        $cmd = $argv[1];
    }

    /** Run the command. */
    switch($cmd){
        case '-h':
        case '--help':
        case 'list':
            /** Show available commands. */
            show_commands();
            break;
        case 'compile':
            /** Compile everything. */
            compile_less( $argv );
            compile_customizer( $argv );
            break;
        case 'compile:backend':
        case 'compile:customizer':
            /** Compile backend code: Customizer JavaScript and CSS. */
            compile_customizer( $argv );
            break;
        case 'compile:dev':
            /**
            * Start an infinite loop and recompile files that
            * have changed every 15 seconds.
            */
            set_time_limit(0);
            echo 'Recompiling changes to Wiki Modern every 15 seconds. Close this terminal or interrupt the execution to stop:' . PHP_EOL;
            while(true){
                compile_less( NULL );
                compile_customizer( NULL );
                sleep(15);
            }
            break;
        case 'compile:frontend':
        case 'compile:less':
            /** Compile frontend code: the themes LESS and JavaScript optionally. */
            compile_less( $argv );
            break;
        case 'compile:release':
            if( !empty( $argv[2] ) ){
                $version = parse_version( $argv[2] );
                if( $version != null ){
                    // TODO: Add an optional JavaScript compiler.
                    /** Force a compile of everything first. */
                    compile_less( array('','','-f') );
                    compile_customizer( array('','','-f') );
                    release( $version );
                    return;
                }
            }
            echo "\033[0;31mYou must provide a valid semantic version number such as:" . PHP_EOL;
            echo '#.#.#' . PHP_EOL;
            echo "#.#.#-rc \033[0m" . PHP_EOL;
            break;
        default:
            if( strlen($cmd) < 1 ){
                /** No command given show available commands. */
                show_commands();
            } else {
                /** Invalid command. */
                echo "Command not recognized. Type\033[1;33m php wmc --help\033[0m to see available commands." . PHP_EOL;
            }
            break;
    }

    // http://blog.lenss.nl/2012/05/adding-colors-to-php-cli-script-output/
    // https://stackoverflow.com/questions/5947742/how-to-change-the-output-color-of-echo-in-linux

} else {
    /** Command line usage was not detected. Show warning and die. */
    echo 'The Wiki Modern compiler can only be used via command line for security purposes.';
    die();
}

/**
* Prepare the release directory for a new release.
*
* @param String $version The semantic version number for this release.
*/
function check_release_dir( $version ){
    /** Make the release directory if it doesn't exist. */
    if( !file_exists( 'RELEASE' ) ){
        mkdir( 'RELEASE' );
    }
    /** Delete any compiled releases with the same name. */
    if( !empty($version) ){
        $zip_file = 'RELEASE/wiki-modern-' . $version . '.zip';
    } else {
        $zip_file = 'RELEASE/wiki-modern.zip';
    }
    if( file_exists( $zip_file ) ){
        unlink( $zip_file );
    }
}

/** Compile JavaScript and CSS files used by the Customizer. */
function compile_customizer( $options ){

    /** Force compile? */
    $override_compile = false;
    if( !empty( $options[2] ) ){
        switch($options[2]){
            case '-f':
            case '-force':
            case '--force':
                $override_compile = true;
                break;
        }
    }

    /** Load timestamps of file changes. */
    $last_updated = @file_get_contents( 'customizer/timestamps.json' );
    $compile_flag = false;
    if( !empty($last_updated) ){
        $last_updated = json_decode( $last_updated, true );
    } else {
        $last_updated = array();
        $compile_flag = true;
    }

    /** Record directories we need to check. */
    $dirs = array(
        'customizer/css/panel',
        'customizer/css/preview',
        'customizer/js/panel',
        'customizer/js/preview'
    );

    /** Ignore these when reading through directory content. */
    $ignore = array(
        '.',
        '..'
    );

    /** Read through the directories. */
    foreach( $dirs as $dir ){
        // TODO: Force / in path with a function to clean $file
        if( file_exists( $dir ) ){
            $files = scandir($dir);
            foreach( $files as $file ){

                $fullpath = $dir . '/' . $file;

                /** Only process files not in the ignore list. */
                if( !in_array( $file, $ignore ) ){

                    /**
                    * Check if this file has changed. As soon as one file is found
                    * changed stop checking because a full recompile is needed.
                    */
                    if( $compile_flag == false && @$last_updated[ make_key( $fullpath ) ] ){
                        if( $last_updated[ make_key( $fullpath ) ] != filemtime($fullpath) ){
                            $compile_flag = true;
                        }
                    }

                    /** Record the last updated time of each file. */
                    $timestamps[ make_key( $fullpath ) ] = filemtime($fullpath);
                }
            }
        }
    }

    /** Recompile files if something changed. */
    if( $compile_flag == true || $override_compile == true ){

        foreach( $dirs as $dir ){

            $ext = '';
            $source = '';
            $type = '';
            $files = scandir($dir);

            foreach( $files as $file ){

                $fullpath = $dir . '/' . $file;

                /** Get the files contents (source). */
                $contents = file_get_contents( $fullpath );

                /** Remove comments. */
                $contents = preg_replace('/(?:(?:\/\*(?:[^*]|(?:\*+[^*\/]))*\*+\/)|(?:(?<!\:|\\\|\'|\")\/\/.*))/', '', $contents);

                /** Remove empty lines. */
                $source .= preg_replace("/(^[\r\n]*|[\r\n]+)[\s\t]*[\r\n]+/", "\n", $contents);
            }

            /** Pull the correct file type out of the file path. */
            if( stristr( $dir, 'preview' ) != false ){
                $type = 'preview';
            } else {
                $type = 'panel';
            }

            /** Pull the correct file extension out of the file path. */
            if( stristr( $dir, 'css' ) != false ){
                $ext = 'css';
            } else {
                $ext = 'js';
            }

            /**
            * Remove empty lines left over from the ending line of each file
            * that was read. Text editors add these lines sometimes.
            */
            $source = preg_replace("/(^[\r\n]*|[\r\n]+)[\s\t]*[\r\n]+/", "\n", $source);

            /** Save the new compiled file. */
            if( $ext == 'js' ){
                $source = '( function( $ ) {' . PHP_EOL . $source . PHP_EOL . '} )( jQuery );';
            }
            file_put_contents( 'customizer/' . $ext . '/customizer-' . $type . '.' .$ext, $source );

            if( $ext == 'css' ){
                if( $type == 'preview' ){
                    echo timestamp() . 'Customizer preview CSS compiled successfully.' . PHP_EOL;
                } else {
                    echo timestamp() . 'Customizer panel CSS compiled successfully.' . PHP_EOL;
                }
            } else {
                if( $type == 'preview' ){
                    echo timestamp() . 'Customizer preview JavaScript compiled successfully.' . PHP_EOL;
                } else {
                    echo timestamp() . 'Customizer panel JavaScript compiled successfully.' . PHP_EOL;
                }
            }
        }
    }

    /** If a recompile happened save the new timestamps. */
    if( $compile_flag == true || $override_compile == true ){
        file_put_contents('customizer/timestamps.json', json_encode( $timestamps ) );
    }
}

/** Compile LESS into a single CSS file. */
function compile_less( $options ){

    /** Force compile? */
    $override_compile = false;
    if( !empty( $options[2] ) ){
        switch($options[2]){
            case '-f':
            case '-force':
            case '--force':
                $override_compile = true;
                break;
        }
    }

    /** Ignore these when reading through directory content. */
    $ignore = array(
        '.',
        '..',
        'timestamps.json'
    );

    /** Load timestamps of file changes. */
    $last_updated = @file_get_contents( 'less/timestamps.json' );
    $compile_flag = false;

    /** Check if we actually found timestamps. */
    if( !empty($last_updated) ){
        $last_updated = json_decode( $last_updated, true );
    } else {
        /** We have no timestamps saved compile. */
        $compile_flag = true;
    }

    /** Check for any changes. */
    $files = scandir('less');
    foreach( $files as $file ){

        /** Only process files not in the ignore list. */
        if( !in_array( $file, $ignore ) ){

            $fullpath = 'less/' . $file;

            /**
            * Check if this file has changed. As soon as one file is found
            * changed stop checking because a full recompile is needed.
            */
            if( $compile_flag == false ){
                if( @$last_updated[ make_key( $fullpath ) ] != filemtime($fullpath) ){
                    /** This file has changed run the compiler. */
                    $compile_flag = true;
                }
            }

            /** Record the latest file update time. */
            $timestamps[ make_key( $fullpath ) ] = filemtime($fullpath);
        }

    }

    /** Do we need to compile? */
    if( $compile_flag == true || $override_compile == true){

        /**
        * If in auto-compile mode (dev mode) block loading the LESS
        * compiler multiple times.
        */
        if( !in_array( realpath('include/less'), get_included_files()) ){
            require( 'include/less' );
        }
        $less_compiler = new lessc;

        /** If the sites user has custom colors use them instead. **/
        $custom_flag = false;
        if( file_exists( 'etc/colors.less' ) ){
            /** Move the production file temporarily. */
            rename( 'less/colors.less', 'less/___tmp-colors.less' );
            copy( 'etc/colors.less', 'less/colors.less' );
            $custom_flag = true;
        }

        /** Attempt to compile LESS. */
        try {
            $source = $less_compiler->compileFile("less/main.less");
            file_put_contents( 'css/main.css', $source );
            echo timestamp() . 'Theme LESS compiled successfully.' . PHP_EOL;
        } catch(Exception $e){
            echo timestamp() . "\033[0;31mThere was an error compiling the theme LESS code: " . PHP_EOL . PHP_EOL;
            echo $e . PHP_EOL . "\033[0m";
        }

        /** Restore files if needed. */
        if( $custom_flag ){
            unlink( 'less/colors.less' );
            rename( 'less/___tmp-colors.less', 'less/colors.less' );
        }

        /** Save updated timestamps and clean up. */
        file_put_contents('less/timestamps.json', json_encode($timestamps) );
        $less_compiler = NULL;
        unset($less_compiler);
    }
}

function timestamp(){
    return '[' . date( 'H:i:s' ) . '] ';
}

/**function get_php_exec(){
    if ( defined('PHP_BINARY') && PHP_BINARY && in_array(PHP_SAPI, array('cli', 'cli-server')) && is_file(PHP_BINARY) ){
        return PHP_BINARY;
    } else if ( strtoupper(substr(PHP_OS, 0, 3)) === 'WIN' ){
        $paths = explode( PATH_SEPARATOR, getenv('PATH') );
        foreach ( $paths as $path ) {
            if ( substr( $path, strlen($path)-1 ) == DIRECTORY_SEPARATOR ) {
                $path=substr( $path, 0, strlen($path)-1 );
            }
            if ( substr( $path, strlen($path) - strlen('php')) == 'php' ) {
                $response=$path.DIRECTORY_SEPARATOR.'php.exe';
                if ( is_file($response) ) {
                    return $response;
                }
            } else if ( substr($path, strlen($path) - strlen('php.exe')) == 'php.exe' ) {
                if ( is_file($response) ) {
                    return $response;
                }
            }
        }
    } else {
        $paths = explode(PATH_SEPARATOR, getenv('PATH'));
        foreach ( $paths as $path ) {
            if ( substr($path, strlen($path)-1) == DIRECTORY_SEPARATOR ) {
                $path=substr($path, strlen($path)-1);
            }
            if ( substr($path, strlen($path) - strlen('php')) == 'php' ) {
                if ( is_file($path) ) {
                    return $path;
                }
                $response = $path . DIRECTORY_SEPARATOR . 'php';
                if (is_file($response)) {
                    return $response;
                }
            }
        }
    }
    return null;
}
* Determine where the PHP executable is on the server.
*
* @author   ZipXap
* @link     https://stackoverflow.com/a/32997437/3193156 Original source code.
*/

/** Check if the user is using a CLI. */
function is_cli(){
    if ( defined('STDIN') ){ return true; }
    if ( php_sapi_name() === 'cli' ){ return true; }
    if ( array_key_exists('SHELL', $_ENV) ){ return true; }
    if ( empty($_SERVER['REMOTE_ADDR']) and !isset($_SERVER['HTTP_USER_AGENT']) and count($_SERVER['argv']) > 0){ return true; }
    if ( !array_key_exists('REQUEST_METHOD', $_SERVER) ){ return true; }
    return false;
}

/**
* Convert a relative path to a safe array key.
*
* @param String A relative path to a resource.
* @return String Path with slahes replaced by hyphens.
*/
function make_key( $string ){
    return str_replace( '\\', '-', str_replace( '/', '-', $string ) );
}

/**
* Comments are not allowed in JSON so remove any found in a JSON file.
*
* @param String $source The JSON source code to clean.
* @return Array An associative array representing this JSON object.
*/
function parse_json( $source ){
    /** Remove comments. */
    $source = preg_replace('/(?:(?:\/\*(?:[^*]|(?:\*+[^*\/]))*\*+\/)|(?:(?<!\:|\\\|\'|\")\/\/.*))/', '', $source);
    /** Remove empty lines. */
    $source = preg_replace("/(^[\r\n]*|[\r\n]+)[\s\t]*[\r\n]+/", "\n", $source);
    /** Parse JSON. */
    return json_decode( $source, true );
}

/**
* Parse a valid semantic version number.
*
* @param String $version The version number to check.
* @return String|NULL A valid semantic version number or null.
*/
function parse_version( $version ){

    /** Remove characters not allowed in version numbers. */
    $version = preg_replace('/[^\.\-A-Za-z0-9]+/', '', $version);

    /** Start building a validated version number. */
    $number = $version;
    $note = '';

    /** Does this version have a classification? */
    if( strpos( $version, '-' ) > 0 ){

        /** Yes. Pull them apart and validate separately. */
        $number = substr( $version, 0, strpos( $version, '-' ) );
        $note = substr( $version, strpos( $version, '-' ) + 1 );
        if( strlen($note) > 1 ){ $note = '-' . $note; }
    }

    /** Make sure we have a valid semantic version number: major.minor.patch */
    $invalid = true;
    if( substr_count( $number, '.') == 2 ){
        $parts = explode( '.', $number);
        if( !is_int($parts[0]) ){ $invalid = true; }
        if( !is_int($parts[1]) ){ $invalid = true; }
        if( !is_int($parts[2]) ){ $invalid = true; }
        $invalid = false;
    }

    /** Return the validated semantic version or NULL. */
    if( !$invalid ){
        return $number . $note;
    } else {
        return NULL;
    }
}

/**
* Recursively add files to the release ZIP folder.
*
* @param String $version A semantic version number for this relase.
*/
function release( $version ){

    /** Load config file. */
    $config = parse_json( file_get_contents( 'bin/config' ) );
    $text_domain = $config['text-domain'];

    /** Load the template used to include or ingore files for relase. */
    $template = parse_json( file_get_contents( 'bin/release' ) );

    /** Loop through and correct template structure. */
    foreach( $template as $index => $group ){
        foreach ( $group as $key => $value ) {
            /** Add currect directory prefix so in_array checks match correctly. */
            $group[$key] = './' . $value;
            /** Use the systems correct directory sperator so in_array checks match correctly. */
            $group[$key] = str_replace( '/', DIRECTORY_SEPARATOR, $group[$key] );
        }
        $template[$index] = $group;
    }

    /**
    * Make the release directory if we do not have one already and
    * delete any past releases that were compiled.
    */
    check_release_dir( $version );

    /** Initialize archive object. */
    $zip = new ZipArchive();

    /** Add the version to the zip file name. */
    $zip_file = getcwd() . DIRECTORY_SEPARATOR . 'RELEASE' . DIRECTORY_SEPARATOR . $text_domain . '-' . $version . '.zip';

    /** Open the ZIP file for work. */
    $zip->open( $zip_file, ZipArchive::CREATE );

    /** Loop through our dev files and save production code to the zip file. */
    release_recursive_compile( '.', DIRECTORY_SEPARATOR, $text_domain, $template, $zip );

    /** Add files where their directories where ignored. */
    foreach ($template['save'] as $file ) {
        $zip->addFile( substr($file, 2), $text_domain . '/' . substr($file, 2) );
    }

    /** Complie the style.css file required by Word Press. */
    $style = file_get_contents( 'style.css' );
    $license = file_get_contents( 'bin/license' );

    /** Swap the values from the config file into the license file. */
    $years = $config['copyright-start'];
    if( date( 'Y' ) > $config['copyright-start'] ){
        $years .= '-' . date( 'Y' );
    }
    $tags = '';
    foreach( $config['tags'] as $tag ){
        $tags .= $tag . ', ';
    }
    $tags = substr( $tags, 0, strlen($tags) -2 );
    $license = str_replace( '{{author-uri}}', $config['author-uri'], $license);
    $license = str_replace( '{{author}}', $config['author'], $license);
    $license = str_replace( '{{description}}', $config['description'], $license);
    $license = str_replace( '{{license}}', $config['license'], $license);
    $license = str_replace( '{{license-uri}}', $config['license-uri'], $license);
    $license = str_replace( '{{tags}}', $tags, $license);
    $license = str_replace( '{{text-domain}}', $text_domain, $license);
    $license = str_replace( '{{theme-name}}', $config['theme-name'], $license);
    $license = str_replace( '{{theme-text-domain}}', $config['theme-text-domain'], $license);
    $license = str_replace( '{{theme-uri}}', $config['theme-uri'], $license);
    $license = str_replace( '{{years}}', $years, $license);
    $license = str_replace( '{{version}}', $version, $license);
    file_put_contents( '___tmp-style.css', $license . PHP_EOL . $style);
    $zip->addFile( '___tmp-style.css', $text_domain . '/style.css' );

    /** Close the Zip file; archives will only be created after closing the object. */
    $result = $zip->close();

    /** Report on outcome. */
    if( $result ){
        echo timestamp() . 'Theme was compiled successfully for production. The ZIP file is located in the RELEASE directory.' . PHP_EOL;
    } else {
        echo timestamp(). "\033[0;31mThe theme did not compile properly.\033[0m" . PHP_EOL;
    }

    /** Clean up style file. */
    unlink('___tmp-style.css');
}

/**
* Recursively add files to the release ZIP folder.
*
* @param String $current_dir The current directory path (parents).
* @param String $separator The correct directory separator for this OS.
* @param String $text_domain The themes text domain; theme name with no spaces.
* @param Array $template An array of directories and files to skip.
* @param ZipArchive $zip A reference to the ZIP file being used.
*/
function release_recursive_compile( $current_dir, $separator, $text_domain, $template, $zip ){

    $dir = scandir($current_dir);

    foreach ($dir as $content ){
        if( $content != '.' && $content != '..' ){
            $fullpath = $current_dir . $separator . $content;
            if( is_dir($fullpath) ){
                if( !in_array( $fullpath, $template['directories'] ) ){
                    $zip->addEmptyDir( $text_domain . '/' . substr($fullpath, 2) );
                    release_recursive_compile( $fullpath, $separator, $text_domain, $template, $zip);
                }
            } else {
                if( !in_array( $fullpath, $template['files'] )){
                    $zip->addFile( substr($fullpath, 2), $text_domain . '/' . substr($fullpath, 2) );
                }
            }
        }
    }
}

/**
* Recursive delete directory and files.
*
* @author PHP Manual <http://php.net/manual/en/function.rmdir.php>
*/
function rrmdir($dir) {
    if (is_dir($dir)) {
     $objects = scandir($dir);
     foreach ($objects as $object) {
       if ($object != "." && $object != "..") {
         if (is_dir($dir."/".$object))
           rrmdir($dir."/".$object);
         else
           unlink($dir."/".$object);
       }
     }
     rmdir($dir);
   }
}

function show_commands(){
    echo 'Showing command list is not implemented yet.' . PHP_EOL;
/*
Usage:
  command [options] [arguments]

Options:
  -h, --help            Display this help message
  -q, --quiet           Do not output any message
  -V, --version         Display this application version
      --ansi            Force ANSI output
      --no-ansi         Disable ANSI output
  -n, --no-interaction  Do not ask any interactive question
  -v|vv|vvv, --verbose  Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug

Available commands:
  help                                     Displays help for a command
  list                                     Lists commands
 admin
  admin:user:create                        Creates an administrator
  admin:user:unlock                        Unlock Admin Account
 app
  app:config:dump                          Create dump of application
  app:config:import                        Import data from shared configuration files to appropriate data storage
 cache
  cache:clean                              Cleans cache type(s)
  cache:disable                            Disables cache type(s)
  cache:enable                             Enables cache type(s)
  cache:flush                              Flushes cache storage used by cache type(s)
  cache:status                             Checks cache status
*/
}
