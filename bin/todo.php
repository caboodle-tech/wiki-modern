<?php
/**
 * Automatically Build a Project To-Do List
 *
 * This application will automatically search your projects files and build a to-do list
 * from TODO comments found in the source files. Each TODO comment will be appended with
 * a unique ID that can be used to refer to that item by your team. If your team is
 * using a version control system we recommend using the ID as a branch pre-fix so
 * team members know exactly what that branch is for by referencing the to-do list.
 *
 * NOTE: Comments must be on a single line and start with: // TODO:
 *
 * @author Christopher Keers <source@caboodle.tech>
 */


/**
 * Path to your projects root directory.
 *
 * Can be a relative path (default is ../ because we assume you have a bin directory) or
 * a full system file path.
 */
$path_to_project = '../';

/**
 * To-Do File Header Message
 *
 * Edit this message to fit your needs. Do not use \n or \r for newlines, instead use PHP_EOL.
 */
$header_message = '# AUTO TO-DO LIST' . PHP_EOL . 'This list was auto generated by running /bin/todo.php If you have time and the desire to help please have a look at one of these to-do items or an open issue.';

/**
 * Which file types would you like processed?
 */
$file_types = array( 'js', 'php', 'html', 'less' );

/**
 * Auto add a period (.) to the end of TODO comments that do not end with one of these symbols.
 */
$end_lines = array( '.', '?', '!', ';', '>' );


/**
 * DO NOT EDIT BEYOND THIS POINT
 */


/**
 * Only run if the user is using the command line or an equivalent shell or terminal.
 */
if ( is_cli() === true && http_response_code() === false ) {

    class ToDo {

        private $base_path;

        // [TODO][BO20W4432] Make sure (>) is always included in the end of line list or HTML comments will break.
        private $end_lines = array( '.', '?', '!', ';', '>' );

        private $error_flag = false;

        private $file_types = array( 'js', 'php', 'html', 'less' );

        // [TODO][BO20W4433] Add feature here: Dynamically add the path instead of hard coding /bin/todo.php.
        private $header_message = '# AUTO TO-DO LIST' . PHP_EOL . 'This list was auto generated by running /bin/todo.php If you have time and the desire to help please have a look at one of these to-do items or an open issue.';

        private $md_todo_list;

        private $offset = 0;

        private $time;

        public function __construct( $path = false, $msg = false, $files = false, $end = false ) {

            if ( $path != false ) {
                $result = @chdir( $path );
                if ( $result ) {
                    $this->base_path = getcwd();
                } else {
                    $this->error( 'The path you provided to your projects root directory is not a valid system path.' );
                    $this->error_flag = true;
                }
            }

            if ( $msg != false && ! empty( $msg ) ) {
                $this->header_message = $msg;
            }

            if ( $files != false && is_array( $files ) ) {
                $this->file_types = $files;
            } else {
                $this->error( 'There is a problem with the file types to process. Please make sure your provided an array of file types.' );
                $this->error_flag = true;
            }

            if ( $end != false && is_array( $end ) ) {
                $this->end_lines = $end;
            } else {
                $this->error( 'There is a problem with the end of line options. Please make sure your provided an array of valid line endings.' );
                $this->error_flag = true;
            }
        }

        private function check_time() {

            $old_list = 'TODO.md';

            if( file_exists( getcwd() . '/' . $old_list ) ){

                $old_list = file_get_contents( getcwd() . '/' . $old_list );
                preg_match_all( '/ \[\w+\]/', $old_list, $matches );
                $last_id = str_replace( array( ' ', '[', ']' ), '', $matches[0][ count( $matches[0] ) - 1 ] );
                $this->time = $this->get_time( $last_id );

            } else {

                $this->time = time();

            }
        }

        private function error( $msg ) {
            echo "\033[0;31m$msg\033[0m" . PHP_EOL;
        }

        private function get_extension( $file ) {
            $dot = strrpos( $file, '.' );
            if ( $dot > 0 ) {
                return substr( $file, $dot + 1 );
            }
            return $file;
        }

        private function get_id( $offset = 0 ) {
            $sub = array( 'A', 'B', 'C', 'D', 'E', 'F',
                          'G', 'H', 'I', 'J', 'K', 'L',
                          'M', 'N', 'O', 'P', 'Q', 'R',
                          'S', 'T', 'U', 'V', 'W', 'X',
                          'Y', 'Z', '1', '2', '3', '4',
                          '5' );
            $id = gmdate( 'n:j:y:H:is', $this->time + $this->offset );
            $id = explode( ':', $id );

            $id[0] = $sub[ (int) $id[0] ];
            $id[1] = $sub[ (int) $id[1] ];
            $id[3] = $sub[ (int) $id[3] ];

            return implode( $id );
        }

        private function get_time( $id ) {
            $id = str_split( $id );
            $sub = array( 'A', 'B', 'C', 'D', 'E', 'F',
                          'G', 'H', 'I', 'J', 'K', 'L',
                          'M', 'N', 'O', 'P', 'Q', 'R',
                          'S', 'T', 'U', 'V', 'W', 'X',
                          'Y', 'Z', '1', '2', '3', '4',
                          '5' );
              $id[0] = array_search( $id[0], $sub );
              $id[1] = array_search( $id[1], $sub );
              $id[4] = array_search( $id[4], $sub );

              $time = $id[1] . '-' . $id[0] . '-' . $id[2] . $id[3] . ' ' . $id[4] . ':' . $id[5] . $id[6] . ':' . $id[7] . $id[8];
              $time = strtotime( $time );

              if ( $time > time() ) {
                  return $time + 1;
              } else {
                  return time();
              }
        }

        private function process( $file ) {

            $clean  = array('<!--', '-->', '[TODO]' );
            $data   = file_get_contents( $file );
            $end    = '';
            $header = false;
            $id     = '';
            $pad    = '';
            $path   = str_replace( $this->base_path, '', $file );
            $tmp    = '';

            // Find recorded todo comments.
            preg_match_all( '/\[TODO\]\[\w+\].+/im', $data, $recorded, PREG_OFFSET_CAPTURE );

            // [TODO][BO20X2049] Change this to organize the todo list by line numbers. Right now it adds old items before new items.

            // Clean and build the recorded todo comments for the TODO.md file.
            if ( count( $recorded[0] ) > 0  ) {
                $header = true;
                $this->md_todo_list .= '# ' . $path . PHP_EOL;

                foreach( $recorded[0] as $record ) {

                    // Find the to-do's line number.
                    list( $before ) = str_split( $data, $record[1] );
                    $line_number = substr_count( $before, PHP_EOL ) + 1;

                    $this->md_todo_list .= '- [ ] '. trim( str_replace( $clean, '', $record[0] ) );
                    $this->md_todo_list .= ' (line ' . $line_number . ')' . PHP_EOL;
                }
            }

            // Find all todo comments.
            preg_match_all( '/^([ ]*| *<!--[ ]*)\/\/[ ]+TODO:.+/im', $data, $matches, PREG_OFFSET_CAPTURE );

            // Process each comment.
            if ( count( $matches[0] ) > 0 ) {

                if ( ! $header ) {
                    $header = true;
                    $this->md_todo_list .= '# ' . $path . PHP_EOL;
                }

                foreach ( $matches[0] as $match ) {

                    // Find the to-do's line number.
                    list( $before ) = str_split( $data, $match[1] );
                    $line_number = substr_count( $before, PHP_EOL ) + 1;

                    // Capture and format the to-do's text; remove extra space and HTML comments.
                    $tmp = str_ireplace( '// TODO:', '', $match[0] );
                    $tmp = trim( str_replace( $clean, '', $tmp ) );
                    if ( ! in_array( mb_substr( $tmp, -1 ), $this->end_lines ) ) {
                        $tmp .= '.';
                    }

                    // Add an ID number to this to-do and replace the to-do comment in the files data.
                    $id = $this->get_id( $this->offset++ );
                    if ( strpos( $match[0], '//' ) > 1 ) {
                        $pad  = substr( $match[0], 0, strpos( $match[0], '//' ) - 1 ) . ' ';
                    } else {
                        $pad = '';
                    }
                    if ( strpos( $match[0], '<!--' ) !== false ) {
                        $end  = ' -->';
                    } else {
                        $end = '';
                    }
                    $data = str_replace( $match[0], $pad . '// [TODO][' . $id . '] ' . $tmp . $end, $data );

                    // Add this to-do to the report list.
                    $this->md_todo_list .= '- [ ] [' . $id . '] ' . $tmp;
                    $this->md_todo_list .= ' (line ' . $line_number . ')' . PHP_EOL;
                }

                // Save this file and move on to the next one.
                file_put_contents( $file, $data );
            }

            if ( $header ) {
                $this->md_todo_list .= PHP_EOL;
            }
        }

        private function recursive_process( $file ) {
            $files = scandir( $file );
            foreach ( $files as $child ) {
                if ( $child != '.' && $child != '..' ) {
                    if ( in_array( $this->get_extension( $child ), $this->file_types ) && ! is_dir( $file . '/' . $child ) ) {
                        $this->process( $file . '/' . $child );
                    } else {
                        if ( is_dir( $child ) ) {
                            $this->recursive_process( $file . '/' . $child );
                        }
                    }
                }
            }
        }

        public function run() {

            if( ! $this->error_flag ){

                $this->check_time();

                $this->md_todo_list .= $this->header_message . PHP_EOL . PHP_EOL;

                $files = scandir( '.' );

                foreach ( $files as $file ) {
                    if ( $file != '.' && $file != '..' ) {
                        if ( in_array( $this->get_extension( $file ), $this->file_types ) && ! is_dir( getcwd() . '/' . $file ) ) {
                            $this->process( getcwd() . '/' . $file );
                        } else {
                            if ( is_dir( $file ) ) {
                                $this->recursive_process( getcwd() . '/' . $file );
                            }
                        }
                    }
                }

                // Record the last used ID so we do not duplicate.
                $this->md_todo_list .= 'DO NOT REMOVE: [' . $this->get_id( $this->offset++ ) . ']';
                file_put_contents( 'TODO.md', $this->md_todo_list );
            }
        }

    }

} else {

    // Make an empty class and warn the user.
    class ToDo {

        public function __construct() {}

        public function run() {
            echo "\033[0;31mYou must run this script from the command line.\033[0m" . PHP_EOL;
        }
    }
}

/**
 * Checks if the user is using a Command Line Interface
 *
 * @return boolean True is the user is using a CLI, false if not.
 */
function is_cli() {
    if ( defined('STDIN') ) { return true; }
    if ( php_sapi_name() === 'cli' ) { return true; }
    if ( array_key_exists('SHELL', $_ENV) ) { return true; }
    if ( empty($_SERVER['REMOTE_ADDR']) and !isset($_SERVER['HTTP_USER_AGENT']) and count($_SERVER['argv']) > 0) { return true; }
    if ( !array_key_exists('REQUEST_METHOD', $_SERVER) ) { return true; }
    return false;
}

// Attempt to run now.
$todo = new ToDo( $path_to_project, $header_message, $file_types, $end_lines );
$todo->run();
